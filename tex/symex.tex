\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{mathpartir}
\usepackage{geometry}
\usepackage{syntax}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{centernot}


\renewcommand{\syntleft}{}
\renewcommand{\syntright}{}

% -- Semantics stuff  
%     I defined a couple of special commands (see examples in the text below) to make
%     writing inference rules and judgements easier.
\newcommand{\br}[1]{\langle #1 \rangle}

\def\Yields{\Downarrow}
\def\Dom{\textrm{dom }}
\def\Ptr{\textrm{ptr }}
\def\Sel{\textrm{sel}}
\def\Upd{\textrm{upd}}
\def\Max{\textrm{max}}

\def\ArrTy{\textrm{Arr }}
\def\PtrTy{\textrm{Ptr }}


\title{GPTValidationOpsem}
\author{Jasper Geer}
\date{March 2023}
\begin{document}
%% \rho(S) notation from mixing TC paper

\section{Representations}
\subsection{Source Language}
\begin{grammar}
<statement> ::= <compound-statement>
  \alt "if (" <expression> ")" <compound-statement> "else" <compound-statement>
  \alt "while (" <expression> ")" <compound-statement>
  \alt "for (" <statement> ";" <statement> ";" <statement> ")" <compound-statement>
  \alt <qualifier> <type> <name> ";"
  \alt <qualifier> <type> <name> "=" <expression> ";"
  \alt "return" <expression> ";"
  \alt <expression> ";"

<compound-statement> ::= "{" <statement>* "}"

<primary-expression> ::= <identifier>
  \alt <constant>
  \alt <string-literal>
  \alt "(" <expression> ")"

<postfix-expression> ::= <primary-expression>
  \alt <postfix-expression> "[" <expression> "]"
  \alt <name> "(" <argument-list> ")"
  \alt <postfix-expression> "++"
  \alt <postfix-expression> "--"

<unary-expression> ::= <postfix-expression>
  \alt "++" <unary-expression>
  \alt "--" <unary-expression>
  % \alt "&" <unary-expression>
  \alt <unary-operator> <postfix-expression>

<multiplicative-expression> ::= <unary-expression>
  \alt <multiplicative-expression> "*" <unary-expression>
  \alt <multiplicative-expression> "/" <unary-expression>
  \alt <multiplicative-expression> "\%" <unary-expression>

<additive-expression> ::= <multiplicative-expression>
  \alt <additive-expression> "+" <multiplicative-expression>
  \alt <additive-expression> "-" <multiplicative-expression>

<shift-expression> ::= <additive-expression>
  \alt <shift-expression> "<<" <additive-expression>
  \alt <shift-expression> ">>" <additive-expression>
  
<relational-expression> ::= <shift-expression>
  \alt <relational-expression> "<" <shift-expression>
  \alt <relational-expression> ">" <shift-expression>
  \alt <relational-expression> "<=" <shift-expression>
  \alt <relational-expression> ">=" <shift-expression>

<equality-expression> ::= <relational-expression>
  \alt <equality-expression> "==" <relational-expression>
  \alt <equality-expression> "!=" <relational-expression>

<bitwise-and-expression> ::= <equality-expression>
  \alt <and-expression> "&" <equality-expression>

<exclusive-or-expression> ::= <and-expression>
  \alt <exclusive-or-expression> "|" <exclusive-or-expression>

<bitwise-or-expression> ::= <exclusive-or-expression>
  \alt <inclusive-or-expression> "|" <exclusive-or-expression>

<logical-and-expression> ::= <bitwise-or-expression>
  \alt <logical-and-expression> "&&" <bitwise-or-expression>

<logical-or-expression> ::= <logical-and-expression>
  \alt <logical-or-expression> "||" <logical-and-expression>

<conditional-expression> ::= <logical-or-expression>
  \alt <conditional-expression> "?" <expression> ":" <conditional-expression>

<assignment-expression> ::= <conditional-expression>
  \alt <unary-expression> <assignment-operator> <assignment-expression>

<expression> ::= <assignment-expression>

<parameter-list> ::= <qualifier> <type> <name> "," <argument-list>
  \alt <type-qualifier> <type> <name>

<argument-list> ::= <expression> "," <argument-list>
  \alt <expression>

<assignment-operator> ::= "=" | "*=" | "/=" | "\%=" | "+=" | "-="

<unary-operator> ::= "*" | "-" | "!" | "~"

<type-qualifier> ::= "const" | "volatile"

<type-specifier> ::= "int" | "unsigned" | "char" %| "float"

<type> ::= <type-qualifier> <type-specifier>

<function-definition> ::= <type> <name> "(" <parameter-list> ")" <compound-expression>

\end{grammar}

\section{Symbolic Execution}

\subsection{Metavariables}
$e$ - source language expressions\\
$c$ - source language statements\\
$s$ - symbolic expressions\\
$x$ - names\\
$v$ - symbolic values\\

\subsection{Symbolic Expressions}

$\tau$ - symbolic types\\
$s$ - symbolic expressions\\
$x, \alpha$ - symbolic variables\\
$v$ - symbolic values\\

\begin{grammar}

<$s$> ::= $v$ | $x$
  \alt $s$ binop $s$
  \alt unop $s$
  \alt $\Sel(s, s)$
  \alt $\Upd(s, s, s)$
  \alt $x(s,..,s)$
  \alt $s?:s:s$
  \alt $\emptyset$

\end{grammar}

\subsection{Expressions}

\begin{mathpar}
  \inferrule*[Right=\textsc{Literal}]
  {}
  {\langle S;v \rangle\Yields\langle S;v \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{Negate}]
  {\langle S; e \rangle\Yields S';s \rangle}
  {\langle S; \texttt{-$e$} \rangle\Yields\langle S';-s:\tau(s) \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{Add}]
  {\langle S; e_1 \rangle\Yields S_1;s_1 \rangle \\
    \langle S_1; e_2 \rangle\Yields S_2;s_2 \rangle\\
    \tau = \Max(\tau(s_1),\tau(s_2))}
  {\langle S; \texttt{$e_1$ + $e_2$} \rangle\Yields\langle S_2;s_1+s_2:\tau \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{AssignAdd}]
  {\langle S; \texttt{$e_1$} \rangle\Yields\langle S_1;s_1) \rangle \\
  s_1=\Sel(\mu(S_k,s_k)):\tau\\
  \langle S_1; \texttt{$e_2$} \rangle\Yields\langle S_2;s_2 \rangle}
  {\langle S; \texttt{$e_1$ += $e_2$} \rangle\Yields\langle S_2[\mu\mapsto\Upd(\mu(S_2),s_k,s_1 + s_2:\tau)];s_2 \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{FunCall}]
  {\rho(S_1)[x]=(\tau_1,..\tau_n)\rightarrow\tau\\
  \forall i\in 1..n, \langle S_k;e_i \rangle\Yields\langle S_{i+1};s_{i}\rangle}
  {\langle S_1; \texttt{$x$($e_1$,..,$e_n$)} \rangle\Yields\langle S_{n+1};x(s_1:\tau_1,..,s_n:\tau_n):\tau \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{Cast}]
  {\langle S;e \rangle\Yields\langle S';s \rangle}
  {\langle S;\textrm{($\tau$) } e \rangle\Yields\langle S';s:\tau \rangle}
\end{mathpar}

\subsection{Statements}

\begin{mathpar}
  \inferrule*[Right=\textsc{Expression}]
  {\langle S;e \rangle\Yields\langle S';s \rangle}
  {\langle S;\texttt{$e$;} \rangle\Yields\langle S';\emptyset:\textrm{u8}\rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{CompoundStatement}]
  {\forall i\in1..n, \langle S_k;c_i \rangle\Yields\langle S_{i+1};s_{i+1} \rangle}
  {\langle S_1; \texttt{\{$c_1..c_n$\}}\rangle\Yields\langle S_{n+1}[\rho\mapsto\rho(S_1)];s_{n+1} \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{IfElse}]
  {\langle S;e \rangle\Yields\langle S_1;g_1 \rangle \\
    g(S)\centernot\implies g_1 \\
    g(S)\centernot\implies \neg g_1 \\\\
    \langle S_1[g\mapsto g(S_1)\land g_1];c_1 \rangle\Yields\langle S_2;s_2 \rangle \\\\
    \langle S_1[g\mapsto g(S_1)\land\neg g_1];c_1 \rangle\Yields\langle S_3;s_3 \rangle \\\\
    S'=\langle (g_1\textrm{?}g(S_2)\textrm{:}g(S_3));(g_1\textrm{?}\rho(S_2)\textrm{:}\rho(S_3));(g_1\textrm{?}\mu(S_2)\textrm{:}\mu(S_3))}
  {\langle S;\texttt{if $e$ $c_1$ else $c_2$} \rangle\Yields\langle S';\emptyset:\mathrm{u8} \rangle}
\end{mathpar}

%% these two may be unnecessary

% \begin{mathpar}
%   \inferrule*[Right=\textsc{IfTrue}]
%   {\langle S;e \rangle\Yields\langle S_1;g_1 \rangle \\
%     g(S)\implies g_1 \\
%     \langle S_1;c_1 \rangle\Yields\langle S_2;s \rangle}
%   {\langle S;\texttt{if $e$ $c_1$ else $c_2$ } \rangle\Yields\langle S_2;\emptyset \rangle}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Right=\textsc{IfFalse}]
%   {\langle S;e \rangle\Yields\langle S_1;g_1 \rangle \\
%     g(S)\implies \neg g_1 \\
%     \langle S_1;c_2 \rangle\Yields\langle S_2;s \rangle}
%   {\langle S;\texttt{if $e$ $c_1$ else $c_2$} \rangle\Yields\langle S_2;\emptyset \rangle}
% \end{mathpar}

\subsection{Memory}

%% arrays todo

\begin{mathpar}
  \inferrule*[Right=\textsc{Var}]
  {x\in\rho(S)\\
   \rho(S)[x]=\alpha:\Ptr\tau}
  {\langle S;x \rangle\Yields\langle S;\Sel(\mu(S), \alpha):\tau \rangle}
\end{mathpar}


\begin{mathpar}
  \inferrule*[Right=\textsc{Ref}]
  {x\in\rho(S)\\
   \rho(S)[x]=\alpha:\tau}
  {\langle S;\texttt{\&}x \rangle\Yields\langle S;\alpha:\tau\rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{Sel}]
  {\langle S;e \rangle\Yields\langle S';s \rangle\\ 
   \tau(s)=\Ptr\tau}
  {\langle S;\texttt{*}e \rangle\Yields\langle S';\Sel(\mu(S'), s):\tau\rangle}
\end{mathpar}

%% check that s_2 type compatible with s_1?

\begin{mathpar}
  \inferrule*[Right=\textsc{Upd}]
  {\langle S;e_1 \rangle\Yields\langle S_1;s_1) \rangle \\ 
  s_1=\Sel(\mu(S_k), s_k):\tau \\
  \langle S_1;e_2 \rangle\Yields\langle S_2;s_2 \rangle}
  {\langle S; \texttt{\texttt{$e_1$ = $e_2$}}\rangle\Yields\langle S_2[\mu\mapsto\Upd(\mu(S_2), s_k, s_2:\tau)];s_2 \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{Declare}]
  {x\not\in\Dom(\rho(S)) \\
    \alpha\textrm{ is fresh}}
  {\langle S; \texttt{\texttt{$\tau$ $x$;}}\rangle\Yields\langle S[\mu\mapsto\Upd(\mu(S), \alpha, \emptyset:\tau); \rho\mapsto\rho(S)[x\mapsto\alpha:\Ptr\tau]];s \rangle}
\end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{DeclareAssign}]
  {x\not\in\Dom(\rho(S)) \\
  \langle S;e \rangle\Yields\langle S';s \rangle \\
    \alpha\textrm{ is fresh}}
  {\langle S; \texttt{\texttt{$\tau$ $x$ = $e$;}}\rangle\Yields\langle S'[\mu\mapsto\Upd(\mu(S'),\alpha,s);\rho\mapsto \rho(S')[x\mapsto\alpha:\Ptr\tau]];s \rangle}
\end{mathpar}

% \begin{mathpar}
%   \inferrule*[Right=\textsc{UpdLocal}]
%   {\langle S;e_1 \rangle\Yields\langle S_1;\Ptr x \rangle \\ 
%   x\in \Dom\rho(S_1) \\
%   \langle S_1;e_2 \rangle\Yields\langle S_2;s \rangle}
%   {\langle S; \texttt{\texttt{*$e_1$ = $e_2$}}\rangle\Yields\langle S_2[\rho\mapsto (\rho(S_2), (x\rightarrow s)];s \rangle}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Right=\textsc{UpdLocalArr}]
%   {\textrm{toOffset}(e_1)=\texttt{$x$[$e'$]} \\
%     \langle S;e' \rangle\Yields\langle S_1;s_1 \rangle \\ 
%   x\in \Dom\rho(S_1) \\
%   \langle S_1;e_2 \rangle\Yields\langle S_2;s_2 \rangle}
%   {\langle S; \texttt{\texttt{*$e_1$ = $e_2$}}\rangle\Yields\langle S_2[\rho\mapsto (\rho(S_2), (x\rightarrow \Upd(\rho(S_2)[x], s_1, s_2))];s \rangle}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Right=\textsc{SelLocal}]
%   {\langle S;e \rangle\Yields\langle S';\Ptr x \rangle \\
%   \rho(S')[x]=s}
%   {\langle S; \texttt{\texttt{*$e$}}\rangle\Yields\langle S';s \rangle}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Right=\textsc{SelGlobal}]
%   {\langle S;e \rangle\Yields\langle S';s_1 \rangle \\
%     s_1 \not= \Ptr{x}}
%   {\langle S; \texttt{\texttt{*$e$}}\rangle\Yields\langle S';\Sel(\mu(S', s_1)) \rangle}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Right=\textsc{IncPreDirect}]
%   {\rho(S)[x]=s}
%   {\langle S; \texttt{++$x$} \rangle\Yields\langle S[\rho\mapsto(\rho(S),x\rightarrow s+1)];s+1 \rangle}
% \end{mathpar}

% \begin{mathpar}
%   \inferrule*[Right=\textsc{IncPostDirect}]
%   {\rho(S)[x]=s}
%   {\langle S; \texttt{$x$++} \rangle\Yields\langle S[\rho\mapsto(\rho(S),x\rightarrow s+1)];s \rangle}
% \end{mathpar}

\begin{mathpar}
  \inferrule*[Right=\textsc{IncPre}]
  {\langle S;e \rangle\Yields\langle S';s) \rangle \\
  s=\Sel(\mu(S_k), s_k):\tau}
  {\langle S; \texttt{++}e \rangle\Yields\langle S'[\mu\mapsto\Upd(\mu(S'), s_k, s+1:\tau);s+1:\tau]\rangle}
\end{mathpar}


\begin{mathpar}
  \inferrule*[Right=\textsc{IncPost}]
  {\langle S;e \rangle\Yields\langle S';s) \rangle \\
  s=\Sel(\mu(S_k), s_k):\tau}
  {\langle S; \texttt{++}e \rangle\Yields\langle S'[\mu\mapsto\Upd(\mu(S'), s_k, s+1:\tau);s]\rangle}
\end{mathpar}

\end{document}